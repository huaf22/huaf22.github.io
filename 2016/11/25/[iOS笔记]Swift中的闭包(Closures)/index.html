<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · Hexo</title><meta name="description" content=" - Afluy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/images/avatar.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.afluy.site/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="images/avatar.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">主页</a></li><li class="nav-list-item"><a href="https://github.com/huaf22" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/users/86344ec5bfe7/latest_articles" target="_blank" class="nav-list-link">简书</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Nov 25, 2016</div><div class="post-content"><h2 id="iOS笔记-Swift中的闭包-Closures"><a href="#iOS笔记-Swift中的闭包-Closures" class="headerlink" title="[iOS笔记]Swift中的闭包(Closures)"></a>[iOS笔记]Swift中的闭包(Closures)</h2><a id="more"></a>
<p>闭包是自包含的函数代码块,Swift 中的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。</p>
<p>闭包表达式语法的如下一般形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &#123; (parameters) -&gt; returnType in</div><div class="line">     statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>举个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func backwards(s1: String, s2: String) -&gt; Bool &#123;</div><div class="line">    return s1 &gt; s2</div><div class="line">&#125;</div><div class="line">var reversed = names.sort(backwards)</div></pre></td></tr></table></figure></p>
<p>上面例子对应的闭包表达式版本的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> reversed = names.sort(&#123; (s1: String, s2: String) -&gt; Bool in</div><div class="line">    return s1 &gt; s2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="1-闭包特性"><a href="#1-闭包特性" class="headerlink" title="1. 闭包特性"></a>1. 闭包特性</h2><h4 id="1-1-根据上下文推断类型-Inferring-Type-From-Context"><a href="#1-1-根据上下文推断类型-Inferring-Type-From-Context" class="headerlink" title="1.1 根据上下文推断类型(Inferring Type From Context)"></a>1.1 根据上下文推断类型(Inferring Type From Context)</h4><p>任何情况下,通过内联闭包表达式构造的闭包作为参数传递给函数或方法时,都可以推断出闭包的参数和返回值类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = names.sort( &#123; s1, s2 in return s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure></p>
<h4 id="1-2-单表达式闭包隐式返回-Implicit-Return-From-Single-Expression-Clossures"><a href="#1-2-单表达式闭包隐式返回-Implicit-Return-From-Single-Expression-Clossures" class="headerlink" title="1.2 单表达式闭包隐式返回(Implicit Return From Single-Expression Clossures)"></a>1.2 单表达式闭包隐式返回(Implicit Return From Single-Expression Clossures)</h4><p>单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = names.sort( &#123; s1, s2 in s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<h4 id="1-3-参数名称缩写-Shorthand-Argument-Names"><a href="#1-3-参数名称缩写-Shorthand-Argument-Names" class="headerlink" title="1.3 参数名称缩写(Shorthand Argument Names)"></a>1.3 参数名称缩写(Shorthand Argument Names)</h4><p>Swift 自动为内联闭包提供了参数名称缩写功能,您可以直接通过 $0 , $1 , $2 来顺序调用闭包的参数,以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = names.sort( &#123; $0 &gt; $1 &#125; )</div></pre></td></tr></table></figure></p>
<blockquote>
<h5 id="P-S-我们可以进一步精简"><a href="#P-S-我们可以进一步精简" class="headerlink" title="P.S. 我们可以进一步精简"></a>P.S. 我们可以进一步精简</h5><h6 id="运算符函数-Operator-Functions"><a href="#运算符函数-Operator-Functions" class="headerlink" title="运算符函数(Operator Functions):"></a>运算符函数(Operator Functions):</h6><p>Swift 的 String 类型定义了关于大于号( &gt; )的字符串实现,其作为一个函数接受两个 String 类型的参数并返回 Bool 类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = names.sort(&gt;)</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="2-尾随闭包-Trailing-Closures"><a href="#2-尾随闭包-Trailing-Closures" class="headerlink" title="2. 尾随闭包(Trailing Closures)"></a>2. 尾随闭包(Trailing Closures)</h2><p>如果需要将一个很长的闭包表达式作为最后一个参数传递给函数,可以使用尾随闭包来增强函数的可读性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//函数声明</div><div class="line">func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; </div><div class="line">	// 函数体部分</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 以下是不使用尾随闭包进行函数调用</div><div class="line">someFunctionThatTakesAClosure(&#123;</div><div class="line">	// 闭包主体部分 </div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 以下是使用尾随闭包进行函数调用 </div><div class="line">someFunctionThatTakesAClosure() &#123;</div><div class="line">	// 闭包主体部分 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//之前的例子可以写成:</div><div class="line">reversed = names.sort() &#123; $0 &gt; $1 &#125;</div><div class="line"></div><div class="line">//如果函数只需要闭包表达式一个参数,当使用尾随闭包时,甚至可以把 () 省略掉:</div><div class="line">reversed = names.sort &#123; $0 &gt; $1 &#125;</div></pre></td></tr></table></figure>
<h2 id="3-捕获-capturing"><a href="#3-捕获-capturing" class="headerlink" title="3. 捕获(capturing)"></a>3. 捕获(capturing)</h2><p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。<br>Swift 会管理在捕获过程中涉及到的所有内存操作,包括释放不再需要的变量。</p>
<p>即使定义这些常量和变量的原作用域已经不存在,闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中,可以捕获值的闭包的最简单形式是嵌套函数,也就是定义在其他函数的函数体内的函数。<br>嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int &#123;</div><div class="line">     var runningTotal = 0</div><div class="line">     //声明内嵌函数</div><div class="line">     func incrementor() -&gt; Int &#123; </div><div class="line">         runningTotal += amount //内嵌函数引用了外部函数的amount和runningTotal变量</div><div class="line">         return runningTotal</div><div class="line">     &#125;</div><div class="line">     return incrementor</div><div class="line"> &#125;</div><div class="line"></div><div class="line">let incrementByTen = makeIncrementor(forIncrement: 10)</div><div class="line"></div><div class="line">incrementByTen() // 返回的值为10</div><div class="line">incrementByTen() // 返回的值为20</div><div class="line">incrementByTen() // 返回的值为30</div></pre></td></tr></table></figure>
<blockquote>
<p>P.S 上面的方法调用可以引申理解为makeIncrementor函数体是一个class,<br>而incrementor是class中的函数,incrementor函数引用了class中的属性amount和runningTotal</p>
</blockquote>
<p>如果创建了另一个 incrementor ,它会有属于它自己的一个全新、独立的 runningTotal 变量的引用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let incrementBySeven = makeIncrementor(forIncrement: 7)</div><div class="line">incrementBySeven() // 返回的值为7</div></pre></td></tr></table></figure>
<h2 id="4-闭包是引用类型-Closures-Are-Reference-Types"><a href="#4-闭包是引用类型-Closures-Are-Reference-Types" class="headerlink" title="4. 闭包是引用类型(Closures Are Reference Types)"></a>4. 闭包是引用类型(Closures Are Reference Types)</h2><p>上面的例子中, incrementBySeven 和 incrementByTen 是常量,但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。<br>无论将函数或闭包赋值给一个常量还是变量,实际上都是将常量或变量的值设置为对应函数或闭包的引 用。上面的例子中,指向闭包的引用 incrementByTen 是一个常量,而并非闭包内容本身。</p>
<blockquote>
<h5 id="这也意味着如果将闭包赋值给了两个不同的常量或变量-两个值都会指向同一个闭包"><a href="#这也意味着如果将闭包赋值给了两个不同的常量或变量-两个值都会指向同一个闭包" class="headerlink" title="这也意味着如果将闭包赋值给了两个不同的常量或变量,两个值都会指向同一个闭包!"></a>这也意味着如果将闭包赋值给了两个不同的常量或变量,两个值都会指向同一个闭包!</h5></blockquote>
<h2 id="5-非逃逸闭包-Nonescaping-Closures"><a href="#5-非逃逸闭包-Nonescaping-Closures" class="headerlink" title="5. 非逃逸闭包(Nonescaping Closures)"></a>5. 非逃逸闭包(Nonescaping Closures)</h2><p>当一个闭包作为参数传到一个函数中,但是这个闭包在函数返回之后才被执行,我们称该闭包从函数中逃逸。<br>你可以在参数名之前标注 @noescape ,用来指明这个闭包是不允许“逃逸”出这个函数的。<br>将闭包标注 @noescape 能使编译器知道这个闭包的生命周期(闭包只能在函数体中被执行,不能脱离函数体执行,所以编译器明确知道运行时的上下文),从而可以进行一些比较激进的优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func someFunctionWithNoescapeClosure(@noescape closure: () -&gt; Void) &#123;</div><div class="line">    closure()</div><div class="line">&#125;</div><div class="line"></div><div class="line">//函数接受的闭包被添加到一个函数外定义的数组中</div><div class="line">var completionHandlers: [() -&gt; Void] = []</div><div class="line">func someFunctionWithEscapingClosure(completionHandler: () -&gt; Void) &#123;</div><div class="line">    completionHandlers.append(completionHandler)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SomeClass &#123;</div><div class="line">    var x = 10</div><div class="line">    func doSomething() &#123;</div><div class="line">        //将闭包标注为 @noescape 使能在闭包中隐式地引用 self</div><div class="line">        someFunctionWithEscapingClosure &#123; self.x = 100 &#125; </div><div class="line">        someFunctionWithNoescapeClosure &#123; x = 200 &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let instance = SomeClass()</div><div class="line"></div><div class="line">instance.doSomething()</div><div class="line">print(instance.x) // prints &quot;200&quot;</div><div class="line"></div><div class="line">completionHandlers.first?()</div><div class="line">print(instance.x) // prints &quot;100&quot;</div></pre></td></tr></table></figure></p>
<h2 id="6-自动闭包-Autoclosures"><a href="#6-自动闭包-Autoclosures" class="headerlink" title="6. 自动闭包(Autoclosures)"></a>6. 自动闭包(Autoclosures)</h2><p>这种闭包不接受任何参数,当它被调用的时候,会返回被包装在其中的表达式的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</div><div class="line"></div><div class="line">// customerProvider 的类型不是 String ,而是 () -&gt; String </div><div class="line">let customerProvider = &#123; customersInLine.removeAtIndex(0) &#125;</div><div class="line"></div><div class="line">print(&quot;Now serving \(customerProvider())!&quot;) // prints &quot;Now serving Chris!&quot;</div><div class="line">print(customersInLine.count)   // prints &quot;4&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</div><div class="line">func serveCustomer(customerProvider: () -&gt; String) &#123;</div><div class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</div><div class="line">&#125;</div><div class="line">serveCustomer( &#123; customersInLine.removeAtIndex(0) &#125; )</div><div class="line">// prints &quot;Now serving Alex!&quot;</div><div class="line"></div><div class="line"></div><div class="line">使用@autoclosure</div><div class="line">func serveCustomer(@autoclosure customerProvider: () -&gt; String) &#123;</div><div class="line">     print(&quot;Now serving \(customerProvider())!&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">serveCustomer(customersInLine.removeAtIndex(0))</div><div class="line"> // prints &quot;Now serving Ewa!&quot;</div></pre></td></tr></table></figure>
<p>@autoclosure特性暗含了@noescape 特性,如果你想让这个闭包可以“逃逸”,则应该使用@autoclosure(escaping) 特性.</p>
<p>参考资料:The Swift Programming Language</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/25/[RxJava学习笔记]filter方法和OnSubscribeFilter类源码解析/" class="prev">PREV</a><a href="/2016/11/25/[Swift学习笔记]-ObjectMapper-框架/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://www.afluy.site">Afluy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>